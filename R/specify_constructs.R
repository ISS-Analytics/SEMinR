#' Measurement functions
#'
#' \code{constructs} creates the constructs from measurement items by assigning the
#' relevant items to each construct and specifying reflective or formative (composite/causal) measurement models
#'
#' This function conveniently maps measurement items to constructs using
#' root name, numbers, and affixes with explicit definition of formative
#' or reflective relationships
#'
#' @param ... Comma separated list of the construct variable measurement specifications, as generated by the
#'    \code{reflective()}, or \code{composite()} methods.
#'
#' @usage
#'   constructs(...)
#'
#' @seealso See \code{\link{composite}}, \code{\link{reflective}}
#'
#' @examples
#'   mobi_mm <- constructs(
#'     reflective("Image",        multi_items("IMAG", 1:5)),
#'     reflective("Expectation",  multi_items("CUEX", 1:3)),
#'     reflective("Quality",      multi_items("PERQ", 1:7)),
#'     reflective("Value",        multi_items("PERV", 1:2)),
#'     reflective("Satisfaction", multi_items("CUSA", 1:3)),
#'     reflective("Complaints",   single_item("CUSCO")),
#'     reflective("Loyalty",      multi_items("CUSL", 1:3))
#'   )
#' @export
constructs <- function(...) {
  return_list <- list(...)
  names(return_list) <- lapply(return_list, function(x) class(x)[[3]])
  return(return_list)
#   return(matrix(c(...), ncol = 3, byrow = TRUE,
#                 dimnames = list(NULL, c("construct", "measurement", "type"))))
}

#' Reflective construct measurement model specification
#'
#' \code{reflective} creates the reflective measurement model matrix for a specific common-factor,
#' specifying the relevant items of the construct and assigning the relationship of reflective.
#' By definition this construct will be estimated by PLS consistent.
#'
#' This function conveniently maps reflectively defined measurement items to a construct and is estimated
#' using PLS consistent.
#'
#' @param construct_name of construct
#' @param item_names returned by the \code{multi_items} or \code{single_item} functions
#'
#' @usage
#'  reflective(construct_name, item_names)
#'
#' @seealso See \code{\link{composite}}, \code{\link{constructs}}
#'
#' @examples
#'   mobi_mm <- constructs(
#'     reflective("Image",        multi_items("IMAG", 1:5)),
#'     reflective("Expectation",  multi_items("CUEX", 1:3)),
#'     reflective("Quality",      multi_items("PERQ", 1:7)),
#'     reflective("Value",        multi_items("PERV", 1:2)),
#'     reflective("Satisfaction", multi_items("CUSA", 1:3)),
#'     reflective("Complaints",   single_item("CUSCO")),
#'     reflective("Loyalty",      multi_items("CUSL", 1:3))
#'   )
#' @export
reflective <- function(construct_name, item_names) {
  construct_names <- rep(construct_name, length(item_names))
  construct <- c(rbind(construct_names, item_names, "C"))
  class(construct) <- append(class(construct), c("construct", "reflective"))
  return(construct)
}

#' Composite construct measurement model specification
#'
#' \code{composite} creates the composite measurement model matrix for a specific construct,
#' specifying the relevant items of the construct and assigning the relationship of either
#' correlation weights (Mode A) or regression weights (Mode B).
#'
#' This function conveniently maps composite defined measurement items to a construct and is
#' estimated using PLS.
#'
#' @param construct_name of construct
#' @param item_names returned by the \code{multi_items} or \code{single_item} functions
#' @param weights is the relationship between the construct and its items. This can be
#' specified as \code{correlation_weights} or \code{mode_A} for correlation weights (Mode A) or as
#' \code{regression_weights} or \code{mode_B} for regression weights (Mode B). Default is correlation weights.
#'
#' @usage
#'  composite(construct_name, item_names,weights = correlation_weights)
#'
#' @seealso See \code{\link{constructs}}, \code{\link{reflective}}
#'
#' @examples
#'   mobi_mm <- constructs(
#'     composite("Image",        multi_items("IMAG", 1:5), weights = correlation_weights),
#'     composite("Expectation",  multi_items("CUEX", 1:3), weights = mode_A),
#'     composite("Quality",      multi_items("PERQ", 1:7), weights = regression_weights),
#'     composite("Value",        multi_items("PERV", 1:2), weights = mode_B)
#'   )
#' @export
composite <- function(construct_name, item_names, weights = correlation_weights) {
  if (identical(weights, correlation_weights)) {
    composite_type = "A"
  } else if (identical(weights, regression_weights)) {
    composite_type = "B"
  } else {
    stop("Composites must be defined as mode A (correlation weights) or B (regression weights)")
  }
  construct <- c(rbind(construct_name, item_names, composite_type))
  class(construct) <- append(class(construct), c("construct", "composite"))
  return(construct)
}

# arguments:
#   item_name: root name of all items
#   item_numbers: vector of item numbers
#   ...: optional affix arguments
#     prefix: prefix before each item name
#     mid: insert between item name and numbers
#     suffix: suffix after each ite name
#
# e.g.> multi_items("item", 0:3, prefix="X_", mid=".", suffix="_")


#' Multi-items measurement model specification
#'
#' \code{multi_items} creates a vector of measurment names given the item prefix and number range.
#'
#' @param item_name Prefix name of items
#' @param item_numbers The range of number suffixews for the items
#' @param ... Additional Item names and nubers
#'
#' @usage
#'   multi_items(item_name, item_numbers, ...)
#'
#' @seealso See \code{\link{single_item}}
#'
#' @examples
#'   mobi_mm <- constructs(
#'     composite("Image",        multi_items("IMAG", 1:5), weights = correlation_weights),
#'     composite("Expectation",  multi_items("CUEX", 1:3), weights = mode_A),
#'     composite("Quality",      multi_items("PERQ", 1:7), weights = regression_weights),
#'     composite("Value",        multi_items("PERV", 1:2), weights = mode_B)
#'   )
#' @export
multi_items <- function(item_name, item_numbers, ...) {
  affix <- as.data.frame(list(...))
  paste(affix$prefix, item_name, affix$mid, item_numbers, affix$suffix, sep = "")
}

#' Single-item measurement model specification
#'
#' \code{single_item} specifies a single item name to be assigned to a construct.
#'
#' @param item Name of item
#'
#' @usage
#'   single_item(item)
#'
#' @seealso See \code{\link{multi_items}}
#'
#' @examples
#'   mobi_mm <- constructs(
#'     composite("Image",        multi_items("IMAG", 1:5), weights = correlation_weights),
#'     composite("Expectation",  multi_items("CUEX", 1:3), weights = mode_A),
#'     composite("Quality",      multi_items("PERQ", 1:7), weights = regression_weights),
#'     composite("Value",        single_item("PERV1"))
#'   )
#' @export
single_item <- function(item) {
  class(item) <- append(class(item), c("construct","single_item_construct"))
  return(item)
}

#' HOC construct
#'
#' \code{two_stage_HOC} creates the constructs from further constructs using the two-stage method (Becker et al., 2012).
#'
#' This function conveniently maps first order constructs onto second order constructs using
#' construct names.
#'
#' @param construct_name of second order construct
#' @param dimensions the first order constructs
#' @param weights is the relationship between the second order construct and first order constructs. This can be
#' specified as \code{correlation_weights} or \code{mode_A} for correlation weights (Mode A) or as
#' \code{regression_weights} or \code{mode_B} for regression weights (Mode B). Default is correlation weights.
#'
#' @usage
#'  two_stage_HOC(construct_name, dimensions,weights = correlation_weights)
#'
#' @seealso See \code{\link{constructs}}, \code{\link{reflective}}
#'
#' @examples
#'   mobi_mm <- constructs(
#'     composite("Image",        multi_items("IMAG", 1:5), weights = correlation_weights),
#'     composite("Expectation",  multi_items("CUEX", 1:3), weights = mode_A),
#'     two_stage_HOC("Quality",      c("Image","Expectation"), weights = regression_weights),
#'     composite("Value",        multi_items("PERV", 1:2), weights = mode_B)
#'   )
#' @export
two_stage_HOC <- function(construct_name, dimensions, weights = correlation_weights) {
  # TODO remove the duplicated conditional
  if (identical(weights, correlation_weights)) {
    composite_type = "HOCA"
  } else if (identical(weights, regression_weights)) {
    composite_type = "HOCB"
  } else {
    stop("Composites must be defined as mode A (correlation weights) or B (regression weights)")
  }
  construct <- c(rbind(construct_name, item_names, composite_type))
  class(construct) <- append(class(construct), c("construct", "higher_order_composite"))
  return(construct)
}

# Function to create a interaction construct
#' @export
interaction <- function(dimensions, method = two_stage, weights = correlation_weights) {
  int <- function(data, mm, sm, ints, inners, method) {
    interaction_construct <- method(data, mm, sm, ints, inners, weights)
  }
  class(int) <- class(method())
  return(int)
}

#' \code{interaction_ortho} creates interaction measurement items by using the orthogonalized approach..
#'
#' This function automatically generates interaction measurement items for a PLS SEM using the orthogonalized approach..
#'
#' @param construct1 The first construct which is subject to the interaction.
#' @param construct2 The second construct which is subject to the interaction.
#'
#' @usage
#'  # orthogonalization approach as per Henseler & CHin (2010):
#'  interaction_ortho(construct1, construct2)
#'
#' @references Henseler & Chin (2010), A comparison of approaches for the analysis of interaction effects
#' between latent variables using partial least squares path modeling. Structural Equation Modeling, 17(1),82-109.
#'
#' @examples
#' data(mobi)
#'
#' # seminr syntax for creating measurement model
#' mobi_mm <- constructs(
#'   composite("Image",        multi_items("IMAG", 1:5)),
#'   composite("Expectation",  multi_items("CUEX", 1:3)),
#'   composite("Value",        multi_items("PERV", 1:2)),
#'   composite("Satisfaction", multi_items("CUSA", 1:3))
#' )
#' mobi_xm <- interactions(
#'   interaction_ortho("Image", "Expectation"),
#'   interaction_ortho("Image", "Value")
#' )
#'
#' #  structural model: note that name of the interactions construct should be
#' #  the names of its two main constructs joined by a '*' in between.
#' mobi_sm <- relationships(
#'   paths(to = "Satisfaction",
#'         from = c("Image", "Expectation", "Value",
#'                  "Image*Expectation", "Image*Value"))
#' )
#'
#' mobi_pls <- estimate_pls(mobi, mobi_mm, mobi_xm, mobi_sm)
#' summary(mobi_pls)
#'
#' @export
orthogonal <- function(constructs) {
  ortho_construct <- function(data, mm, sm, ints, inners) {
    interaction_name <- paste(constructs[[1]], constructs[[2]], sep="*")
    iv1_items <- mm[mm[, "construct"] == constructs[[1]], "measurement"]
    iv2_items <- mm[mm[, "construct"] == constructs[[2]], "measurement"]

    iv1_data <- as.data.frame(scale(data[iv1_items]))
    iv2_data <- as.data.frame(scale(data[iv2_items]))

    multiples_list <- lapply(iv1_data, mult, iv2_data)
    interaction_data <- do.call("cbind", multiples_list)
    colnames(interaction_data) <- as.vector(sapply(iv1_items, name_items, iv2_items))

    # Create formula
    frmla <- stats::as.formula(paste("interaction_data[,i]",paste(as.vector(c(iv1_items,iv2_items)), collapse ="+"), sep = " ~ "))

    # iterate and orthogonalize
    for(i in 1:ncol(interaction_data)) {
      interaction_data[, i] <- stats::lm(formula = frmla, data = data)$residuals
    }
    return(list(name = interaction_name,
                data = interaction_data
    ))
  }
  class(ortho_construct) <- append(class(ortho_construct), c("construct", "orthogonal_interaction"))
  return(ortho_construct)
}

#' \code{interaction_scaled} creates interaction measurement items by scaled product indicator approach.
#'
#' This function automatically generates interaction measurement items for a PLS SEM using scaled product indicator approach.
#'
#' @param construct1 The first construct which is subject to the interaction.
#' @param construct2 The second construct which is subject to the interaction.
#'
#' @usage
#'  # standardized product indicator approach as per Henseler & Chin (2010):
#'  interaction_scaled("construct1", "construct2")
#'
#' @references Henseler & Chin (2010), A comparison of approaches for the analysis of interaction effects
#' between latent variables using partial least squares path modeling. Structural Equation Modeling, 17(1),82-109.
#'
#' @examples
#' data(mobi)
#'
#' # seminr syntax for creating measurement model
#' mobi_mm <- constructs(
#'   composite("Image",        multi_items("IMAG", 1:5)),
#'   composite("Expectation",  multi_items("CUEX", 1:3)),
#'   composite("Value",        multi_items("PERV", 1:2)),
#'   composite("Satisfaction", multi_items("CUSA", 1:3))
#' )
#' mobi_xm <- interactions(
#'   interaction_scaled("Image", "Expectation"),
#'   interaction_scaled("Image", "Value")
#' )
#'
#' #  structural model: note that name of the interactions construct should be
#' #  the names of its two main constructs joined by a '*' in between.
#' mobi_sm <- relationships(
#'   paths(to = "Satisfaction",
#'         from = c("Image", "Expectation", "Value",
#'                  "Image*Expectation", "Image*Value"))
#' )
#'
#' mobi_pls <- estimate_pls(mobi, mobi_mm, mobi_xm, mobi_sm)
#' summary(mobi_pls)
#'
#' @export
product_indicator <- function(constructs) {
  scaled_interaction <- function(data, mm, sm, ints, inners) {
    interaction_name <- paste(constructs[[1]], constructs[[2]], sep="*")
    iv1_items <- mm[mm[, "construct"] == constructs[[1]], "measurement"]
    iv2_items <- mm[mm[, "construct"] == constructs[[2]], "measurement"]

    iv1_data <- as.data.frame(scale(data[iv1_items]))
    iv2_data <- as.data.frame(scale(data[iv2_items]))

    multiples_list <- lapply(iv1_data, mult, iv2_data)
    interaction_data <- do.call("cbind", multiples_list)
    colnames(interaction_data) <- as.vector(sapply(iv1_items, name_items, iv2_items))
    return(list(name = interaction_name,
                data = interaction_data))
  }
  class(scaled_interaction) <- append(class(scaled_interaction), c("construct", "scaled_interaction"))
  return(scaled_interaction)
}

#' \code{interaction_2stage} creates an interaction measurement item by the two-stage approach.
#'
#' This function automatically generates an interaction measurement item for a PLS SEM using the two-stage approach.
#'
#' @param construct1 The first construct which is subject to the interaction.
#' @param construct2 The second construct which is subject to the interaction.
#'
#' @usage
#'  # two stage approach as per Henseler & Chin (2010):
#'  interaction_2stage("construct1", "construct2")
#'
#' @references Henseler & Chin (2010), A comparison of approaches for the analysis of interaction effects
#' between latent variables using partial least squares path modeling. Structural Equation Modeling, 17(1),82-109.
#'
#' @examples
#' data(mobi)
#'
#' # seminr syntax for creating measurement model
#' mobi_mm <- constructs(
#'   composite("Image",        multi_items("IMAG", 1:5)),
#'   composite("Expectation",  multi_items("CUEX", 1:3)),
#'   composite("Value",        multi_items("PERV", 1:2)),
#'   composite("Satisfaction", multi_items("CUSA", 1:3))
#' )
#' mobi_xm <- interactions(
#'   interaction_2stage("Image", "Expectation")
#' )
#'
#' #  structural model: note that name of the interactions construct should be
#' #  the names of its two main constructs joined by a '*' in between.
#' mobi_sm <- relationships(
#'   paths(to = "Satisfaction",
#'         from = c("Image", "Expectation", "Value",
#'                  "Image*Expectation"))
#' )
#'
#' mobi_pls <- estimate_pls(mobi, mobi_mm, mobi_xm, mobi_sm)
#' summary(mobi_pls)
#'
#' @export
two_stage <- function(constructs) {
  two_stage_interaction <- function(data, mm, sm, ints, inners) {
    interaction_name <- paste(constructs[[1]], constructs[[2]], sep="*")
    # TODO: remove duplicated conditional
    # remove interactions from structural model
    if(length(sm[-which(grepl("\\*", sm[,1])),]) > 0) {
      sm <- sm[-which(grepl("\\*", sm[,1])),,drop=FALSE]
    }
    if(length(sm[-which(grepl("\\*", sm[,2])),]) > 0) {
      sm <- sm[-which(grepl("\\*", sm[,2])),,drop=FALSE]
    }

    # Run the first stage
    measurement_mode_scheme <- sapply(unique(c(sm[,1],sm[,2])), get_measure_mode, mm, USE.NAMES = TRUE)
    first_stage <- seminr::simplePLS(obsData = data,
                                     smMatrix = sm,
                                     mmMatrix = mm,
                                     inner_weights = inners,
                                     measurement_mode_scheme = measurement_mode_scheme)

    interaction_term <- scale(as.matrix(first_stage$construct_scores[,constructs[[1]]] * first_stage$construct_scores[,constructs[[2]]], ncol = 1)[,, drop = FALSE])

    colnames(interaction_term) <- c(interaction_name)

    return(list(name = interaction_name,
                data = interaction_term[,1, drop = FALSE]))
  }
  class(two_stage_interaction) <- append(class(two_stage_interaction), c("construct", "two_stage_interaction"))
  return(two_stage_interaction)
}
