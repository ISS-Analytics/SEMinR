#' Interaction Functions
#'
#' \code{interactions} creates interaction measurement items by multipying all combination of factor items.
#'
#' This function automatically generates interaction measurement items for a PLS SEM.
#'
#' @param ... Interaction Combinations as generated by the \code{interaction_scaled} or
#' \code{interaction_ortho} methods.
#'
#' @usage
#'  # Create two new interactions (factor1.factor2 and factor1.factor3) using
#'
#'  # (1) standardized product indicator approach as per Henseler & Chin (2010):
#'  interactions( interaction_scaled("factor1", "factor2"),
#'            interaction_scaled("factor1", "factor3"))
#'
#'  # (2) orthogonalization approach as per Henseler & CHin (2010):
#'  interactions( interaction_ortho("factor1", "factor2"),
#'            interaction_ortho("factor1", "factor3"))
#'
#' @examples
#' 
#'
#' mobi_xm <- interactions(
#'   interaction_ortho("Image", "Expectation"),
#'   interaction_ortho("Image", "Value")
#' )
#'
#' mobi_pls <- estimate_pls(mobi, mobi_mm, mobi_xm, mobi_sm)
#' print_paths(mobi_pls)
#'
#' @aliases interaction_ortho, interaction_scaled
#'
#' @export
interactions <- function(...) {
  function(data, mm, all_intxns=list(...)) {
    create_interaction <- function(intxn_function) { intxn_function(data, mm) }
    intxns_list <- lapply(all_intxns, create_interaction)
    return(intxns_list)
  }
}

#' \code{interaction_ortho} creates interaction measurement items by multipying all combination of factor items.
#'
#' This function automatically generates interaction measurement items for a PLS SEM.
#'
#' @param ... Interaction Combinations as generated by the \code{interaction_ortho} method.
#'
#' @usage
#'  # Create two new interactions (factor1.factor2 and factor1.factor3) using
#'
#'  # orthogonalization approach as per Henseler & CHin (2010):
#'  interactions( interaction_ortho("factor1", "factor2"),
#'            interaction_ortho("factor1", "factor3"))
#'
#' @examples
#' 
#'
#' mobi_xm <- interactions(
#'   interaction_ortho("Image", "Expectation"),
#'   interaction_ortho("Image", "Value")
#' )
#'
#' mobi_pls <- estimate_pls(mobi, mobi_mm, mobi_xm, mobi_sm)
#' print_paths(mobi_pls)
#'
#' @aliases interaction_ortho, interaction_scaled
#'
#' @export
interaction_ortho <- function(factor1, factor2) {
  function(data, mm) {
    interaction_name <- paste(factor1, factor2, sep=".")
    iv1_items <- mm[mm[, "latent"] == factor1, ][, "measurement"]
    iv2_items <- mm[mm[, "latent"] == factor2, ][, "measurement"]

    iv1_data <- as.data.frame(scale(data[iv1_items]))
    iv2_data <- as.data.frame(scale(data[iv2_items]))

    mult <- function(col) {
      iv2_data*col
    }

    multiples_list <- lapply(iv1_data, mult)
    interaction_data <- do.call("cbind", multiples_list)

    # Create formula
    frmla <- as.formula(paste("interaction_data[,i]",paste(as.vector(c(iv1_items,iv2_items)), collapse ="+"), sep = " ~ "))

    # iterate and orthogonalize
    for(i in 1:ncol(interaction_data)) {
      interaction_data[,i] <- lm(formula = frmla, data = data)$residuals
    }
    return(list(name = interaction_name, data = interaction_data))
  }
}

#' \code{interaction_scaled} creates interaction measurement items by multipying all combination of factor items.
#'
#' This function automatically generates interaction measurement items for a PLS SEM.
#'
#' @param ... Interaction Combinations as generated by the \code{interaction_scaled} method.
#'
#' @usage
#'  # Create two new interactions (factor1.factor2 and factor1.factor3) using
#'
#'  # standardized product indicator approach as per Henseler & Chin (2010):
#'  interactions( interaction_scaled("factor1", "factor2"),
#'            interaction_scaled("factor1", "factor3"))
#'
#' @examples
#' 
#'
#' mobi_xm <- interactions(
#'   interaction_scaled("Image", "Expectation"),
#'   interaction_scaled("Image", "Value")
#' )
#'
#' mobi_pls <- estimate_pls(mobi, mobi_mm, mobi_xm, mobi_sm)
#' print_paths(mobi_pls)
#'
#' @aliases interaction_ortho, interaction_scaled
#'
#' @export
interaction_scaled <- function(factor1, factor2) {
  function(data, mm) {
    interaction_name <- paste(factor1, factor2, sep=".")
    iv1_items <- mm[mm[, "latent"] == factor1, ][, "measurement"]
    iv2_items <- mm[mm[, "latent"] == factor2, ][, "measurement"]

    iv1_data <- as.data.frame(scale(data[iv1_items]))
    iv2_data <- as.data.frame(scale(data[iv2_items]))

    mult <- function(col) {
      iv2_data*col
    }

    multiples_list <- lapply(iv1_data, mult)
    interaction_data <- do.call("cbind", multiples_list)

    return(list(name = interaction_name, data = interaction_data))
  }
}

